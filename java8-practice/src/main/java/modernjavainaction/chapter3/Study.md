# 람다 표현식
- 이 장의 내용
    - 람다란 무엇인가?
    - 어디에, 어떻게 람다를 사용하는가?
    - 실행 어라운드 패턴
    - 함수형 인터페이스, 형식 추론
    - 메서드 참조
    - 람다 만들기
    
동작 파라미터화를 이용해서 변화하는 요구사항에 효과적으로 대응하는 코드를 구현할 수 있음을 챕터2에서 확인했다. 또한 정의한 코드 블록을 다른 메서드로 전달할 수 있다.
정의한 코드블록을 특정 이벤트(예를 들면 마우스 클릭)가 발생할 때 실행되도록 설정하거나 알고리즘의 일부('150그램 이상의 사과'와 같은 프레디케이트)로 실행되도록 설정할 수 있다.
따라서 동작파라미터화를 이용하면 더 유연하고 재사용할 수 있는 코드를 만들 수 있다.

익명 클래스로 다양한 동작을 구현할 수 있지만 만족할 만큼 코드가 깔끔하지는 않았다. 깔끔하지 않은 코드는 동작 파라미터를 실전에 적용하는 것을 막는 요소다.
3장에서는 더 깔끔한 코드로 동작을 구현하고 전달하는 자바 8의 새로운 기능인 람다 표현식을 설명한다. 람다 표현식은 익명 클래스처럼 이름이 없는 함수면서 메서드를 인수로 전달할 수 있으므로 일단은 람다표현식이 익명 클래스와 비슷하다고 생각하자.

이 장에서는 람다 표현식을 어떻게 만드는지, 어떻게 사용하는지, 어떻게 코드를 간결하게 만들 수 있는지 설명한다. 또한 자바 8 API에 추가된 중요한 인터페이스와 형식 추론 등의 기능도 확인한다.
마지막으로 람다 표현식과 함께 위력을 발휘하는 새로운 기능인 메서드 참조를 설명한다.

이 장에서는 더 간결하고 유연한 코드를 구현하는 방법을 단계적으로 설명한다. 이 장의 끝부분에서는 배운 개념을 종합한 예제를 보여준다. 2장에서 소개한 정렬 예제를 더 간단하고 가독성 좋은 코드로 바꿀 것이다. 이 장에서 설명하는 내용 자체도 중요하지만 이 장에서 설명하는 람다 표현식은 전체 책에서 광범위하게 사용하므로 이 장의 내용을 완벽하게 이해해야 한다.

### 3.1 람다란 무엇인가?
- 람다 표현식은 메서드로 전달할 수 있는 익명 함수를 단순화한 것이라고 할 수 있다. 람다 표현식에는 이름은 없지만, 파라미터 리스트, 바디, 반환 형식, 발생할 수 있는 예외 리스트는 가질 수 있다.
람다의 특징을 살펴보자
    - 익명
        - 보통의 메서드와 달리 이름이 없으므로 익명이라 표현한다. 구현해야 할 코드에 대한 걱정거리가 줄어든다.
    - 함수
        - 람다는 메서드처럼 특정 클래스에 종속되지 않으므로 함수라고 부른다. 하지만 메서드처럼 파라미터 리스트, 바디 반환 형식, 가능한 예외 리스트를 포함한다.
    - 전달
        - 람다 표현식을 메서드 인수로 전달하거나 변수로 저장할 수 있다.
    - 간결성
        - 익명 클래스처럼 많은 자질구레한 코드를 구현할 필요가 없다.
    
람다(lambda)라는 용어는 람다 미적분학 학계에서 개발한 시스템에서 유래했다. 람다 표현식이 왜 중요할까?
2장에서 확인한 것처럼 코드를 전달하는 과정에서 자질구레한 코드가 많이 생긴다. 다행이 람다로 이 문제를 해결할 수 있다.
즉, 람다를 이용해서 간결한 방식으로 코드를 전달할 수 있다. 람다가 기술적으로 자바 8 이전의 자바로 할 수 없었던 일을 제공하는 것은 아니다.
다만 동작 파라미터를 이용할 때 익명 클래스 등 판에 박힌 코드를 구현할 필요가 없다. 람다표현식을 이용하면 2장에서 살펴본 동작 파라미터 형식의 코드를 더 쉽게 구현할 수 있다.
결과적으로 코드가 간결하고 유연해진다. 예를 들어 커스터 Comparator 객체를 기존보다 간단하게 구현할 수 있다.

### 예제 3-1 자바 8의 유효한 람다 표현식
***
(String s) -> s.length()    <- String형식의 파라미터 하나를 가지며 int를 반환한다. 람다 표현식에는 return이 함축되어 있으므로 return 문을 명시적으로 사용하지 않아도 된다.
(Apple a) -> a.getWeight() > 150    <- Apple형식의 파라미터 하나를 가지며 boolean(사과가 150그램보다 무거운지 결정)을 반환함
(int x, int y) -> {
    System.out.println("Result:");      <- int형식의 파라미터 두 개를 가지며 리턴값이 없다(void 리턴). 이 예제에서 볼 수 있듯이 람다 표현식은 여러 행의 문자를 여러 행의 문장을 포함할 수 있다.
    System.out.println(x+y);
}
() -> 42        <- 파라미터가 없다면 int 42를 반환한다.
(Apple a1, Apple a2) -> a1.getWeight().compareTo(a2.getWeight())    <- Apple형식의 파라미터 두개를 가지며 int(두 사과의 무게 비교 결과)를 반환한다.
***

### 표 3-1 람다 예제
***
| 사용 사례 | 람다 예제 |
| ------- | ------  |
| Boolean표현식 | (List<String> list) list.isEmpty() | 
| 객체 생성 | new Apple(10) |
| 객체에서 소비 | (Apple a) -> { System.out.println(a.getWeight()) |
| 객체에서 선택/추출 | (String s) -> s.length() |
| 두 값을 조합 | (int a, int b) -> a * b |
| 두 객체 비교 | (Apple a1, Apple a2) -> a1.getWeight().compareTo(a2.getWeight()) |
***

### 어디에, 어떻게 람다를 사용할까?
- 함수형 인터페이스라는 문맥에서 람다 표현식을 사용할 수 있다
- 그렇다면, 함수형 인터페이스란?
    - 추상 메서드가 오직 하나면 함수형 인터페이스

퀴즈 3-2 함수형 인터페이스
다음 인터페이스 중 함수형 인터페이스는 ?
```java
    public interface Adder {
        int add(int a, int b);
    }    
    
    public interface  SmartAdder extends Adder {
        int add(double a, double b);
    }
    
    public interface Nothing{
    
    }
```
정답

<code>Adder</code>만 함수형 인터페이스다.

<code>SmartAdder</code>는 두 추상 add 메서드(하나는 <code>Adder</code>에서 상속받음)를 포함하므로 함수형 인터페이스가 아니다.

<code>Nothing</code>은 추상 메서드가 없으므로 함수형 인터페이스가 아니다.

- 함수형 인터페이스로 뭘 할 수 있을까?
    - 람다 표현식으로 함수형 인터페이스의 추상 메서드 구현을 직접 전달할 수 있으므로 전체 표현식을 함수형 인터페이스의 인스턴스로 취급(기술적으로 따지면 함수형 인터페이스를 구현한 클래스의 인스턴스)할 수 있다.
    다음 예제는 Runnable이 오직 하나의 추상 메서드 run을 정의하는 함수형 인터페이스이므로 올바른 코드다.
      
```java
    Runnable r1 = () -> System.out.println("Hello World 1");  // 람다 사용
    Runnalbe r2 = new Runnable(){   // 익명 클래스 사용
        public void run(){
            System.out.println("Hello World 2");    
        }
    };
    
    public static void process(Runnable r) {
        r.run();
    }
    process(r1);    // "Hello World 1" 출력
    process(r2);    // "Hello World 2" 출력
    process(() -> System.out.println("Hello World 3")); // 직접 전달된 람다 표현식으로 "Hello World 3" 출력
```

퀴즈 3-3 어디에 람다를 사용할 수 있는가?

다음 중 람다 표현식을 올바로 사용한 코드는?
1. execute(() -> {});  
    public void execute(Runnable r) {
        r.run();
    }
   
2. public Callable<String> fetch() {
        return () -> "Tricky example ;-)";
    }
   
3. Predicate<Apple> p = (Apple a) -> a.getWeight();

정답

1번과 2번은 유효한 람다 표현식

첫 번째 예제에서 람다 표현식 () -> {}의 시그니처는 () -> void며 Runnable의 추상 메서드 run의 시그니처와 일치하므로 유효한 람다 표현식이다. 다만 람다의 바디가 비어있으므로 이 코드를 샐항하면 아무 일도 일어나지 않는다.

두 번째 예제도 유효한 람다 표현식이다. fetch 메서드의 반환 형식은 Callable<String>이다. T를 String으로 대치했을 때 Callable<String> 메서드의 시그니처는 () -> String이 된다. () -> "Tricky example ;-)";는 () -> String 시그니처이므로 문맥상 유효한 람다 표현식이다.

세 번째 예제에서 람다 표현식(Apple a) -> a.getWeight()의 시그니처는 (Apple) -> Integer이므로 Predicate<Apple> : (Apple) -> boolean의 test 메서드의 시그니처와 일치하지 않는다. 따라서 유효한 람다 표현식이 아니다.

***
@FunctionalInterface는 무엇인가?

새로운 자바 API를 살펴보면 함수형 인터페이스에 @FunctionalInterface 어노테이션이 추가되어 있다.(3.4절에서 함수형 인터페이스를 자세히 살펴보면서 더 많은 리스트를 소개할 것이다) @FunctionalInterfac는 함수형 인터페이스임을 가리키는 어노테이션이다.
@FuncationalInterface로 인터페이스를 선언했지만 실제로 함수형 인터페이스가 아니면 컴파일러가 에러를 발생시킨다. 예를 들어 추상 메서드가 한 개 이상이라면 "Multiple nonoverriding abstract methods found in interface Foo(인터페이스 Foo에 오버라이드 하지않은 여러 추상 메서드가 있음)"같은 에러가 발생할 수 있다.
***